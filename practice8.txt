Задание 1

Замыкания полезны тем, что позволяют связать данные (лексическое окружение) с функцией, которая работает
с этими данными. Очевидна параллель с объектно-ориентированным программированием, где объекты позволяют
нам связать некоторые данные (свойства объекта) с одним или несколькими методами.

Следовательно, замыкания можно использовать везде, где вы обычно использовали объект с одним единственным методом.

Такие ситуации повсеместно встречаются в web-разработке. Большое количество front-end кода, который мы пишем на
JavaScript,
основано на обработке событий. Мы описываем какое-то поведение, а потом связываем его с событием, которое создаётся
пользователем (например, клик мышкой или нажатие клавиши). При этом наш код обычно привязывается к событию
в виде обратного/ответного вызова (callback): callback функция - функция выполняемая в ответ на возникновение
события.


Задание 2

1.

if (!("a" in window)) {
var a = 1;
}
alert(a);


-> Undefined
Bсе глобальные переменные являются свойствами window. Строка var a = 1 функционально эквивалентно строке window.a = 1.
Сначала объявляется переменная , а затем в ifзаявлении говорится: «Если aне объявлено, инициализируйте aзначение 1».
Конечно, это условие не может быть правдой , и поэтому переменный а остается с его значением по умолчанию, undefined.-->

2.
var b = function a(x) {
x && a(--x);
};
alert(a);

-> Undefined
Именованные выражения функций не считаются объявлениями функций и, следовательно, не могут быть переопределены
объявлениями переменных.
Однако переменная, содержащая выражение b функции, имеет имя, а имя выражения функции a.
а - это число за пределами функции для выражения a(--x)


3.
function a(x) {
return x * 2;
}
var a;
alert(a);


function a(x) {
return x * 2;
}
Jбъявления функций важнее объявлений переменных, если не выполняется инициализация.
Здесь нет инициализации, поэтому в предупреждении отображается исходный код функции.

4.

function b(x, y, a) {
arguments[2] = 10;
alert(a);
}
b(1, 2, 3);

10
Kаждая запись в argumentsобъекте является дубликатом каждого именованного аргумента.
В случае, когда argчисло формальных параметров для Functionобъекта меньше , свойство ToString(arg)
делит свое значение с соответствующим свойством объекта активации. 10 > 3 в предупреждении будет 10.


5.
function a() {
alert(this);
}
a.call(null);

Здесь в this в конечном итоге указывает на глобальный объект window.В предупреждении будет обьект window.
Если thisArg равно null или undefined, вызываемой функции передается глобальный объект как значение this .
Таким образом когда thisArg null передается call(), по умолчанию используется глобальный объект, которым является
window.-->